{{#paper-toolbar}}
  <h2 class="md-toolbar-tools">
    {{#paper-sidenav-toggle class="menu-sidenav-toggle"}}
      {{paper-icon icon="menu"}}
    {{/paper-sidenav-toggle}}
    <span>Autocomplete</span>
  </h2>
{{/paper-toolbar}}

{{#paper-content classNames="md-padding"}}
  <div class="doc-content">

{{#paper-card}}
{{#paper-card-content}}
  <h2>Basic Usage</h2>
  <blockquote>Use <code>\{{paper-autocomplete}}</code> to search for matches from local or remote data sources.</blockquote>

  {{paper-autocomplete disabled=firstDisabled placeholder="Select a Country ..." source=items lookupKey="name" model=myModel}}
    <p>Selected country is
      {{#if myModel}}
        {{myModel.name}}
          ({{myModel.code}})
      {{else}}
          Nothing selected...
      {{/if}}
    </p>
  {{#paper-checkbox checked=firstDisabled}}Disable input{{/paper-checkbox}}



<h3>Template</h3>
{{#code-block language='handlebars'}}
\{{paper-autocomplete placeholder="Select a Country ..." source=items lookupKey="name" model=myModel}}{{/code-block}}

  <h3>Allow non existing items</h3>
  {{paper-autocomplete minLength=0 allowNonExisting=true placeholder="Type e.g. ember, paper, one, two etc." source=arrayOfItems model=sixthModel}}
  <p>Selected thing was:
    {{#if sixthModel}}
      {{sixthModel}}
    {{else}}
      Nothing ...
    {{/if}}
  </p>

{{/paper-card-content}}
{{/paper-card}}


{{#paper-card}}
{{#paper-card-content}}
    <h2>Promise of data (Ember data)</h2>
    <blockquote>You may pass a callback to the source attribute, this callback takes the searchText as an argument and must
    return a promise. This means that it works with e.g. jQuery's "$.getJSON" or Ember Data. When dealing with AJAX the <code>delay</code> attribute
    is recommended to use to set a delay for the search to start.
    </blockquote>

    {{paper-autocomplete minLength=0 delay=300 placeholder="Type e.g. Ram, Test, etc." source=dataFromPromise lookupKey="name" model=otherModel}}
    <p>You have selected:
      {{#if otherModel}}
        {{otherModel.name}}
          ({{otherModel.id}})
      {{else}}
          No Item Selected.
      {{/if}}
    </p>

<h3>Template</h3>
{{#code-block language='handlebars'}}
\{{paper-autocomplete minLength=0 delay=300 placeholder="Type e.g. Ram, Test, etc." source=dataFromPromise lookupKey="name" model=otherModel}}{{/code-block}}
{{/paper-card-content}}
{{/paper-card}}



{{#paper-card}}
{{#paper-card-content}}
    <h2>Custom template</h2>
    <blockquote>Use <code>\{{paper-autocomplete}}</code> with custom templates to show styled autocomplete results. In this example we also use <code>minLength=0</code> which allow to see all results if input is empty.</blockquote>

    {{#paper-autocomplete minLength=0 placeholder="Type e.g. ember, paper, one, two etc." source=arrayOfItems model=fourthModel as |item index notFound|}}
      {{#unless notFound}}
          <span class="item-title">
        {{paper-icon icon="star"}}
              <span> {{item}} (index {{index}} )</span>
          </span>
      {{else}}
          Whoops! Could not find "{{item}}".
      {{/unless}}
    {{/paper-autocomplete}}
    <p>Selected thing was:
      {{#if fourthModel}}
        {{fourthModel}}
      {{else}}
          Nothing selected...
      {{/if}}
    </p>



<h3>Template</h3>
{{#code-block language='handlebars'}}
\{{#paper-autocomplete minLength=0 placeholder="Type e.g. ember, paper, one, two etc." source=arrayOfItems model=fourthModel as |item index notFound|}}
  \{{#unless notFound}}
    &lt;span class="item-title"&gt;
      \{{paper-icon icon="star"}}
    &lt;span&gt; \{{item}} &lt;/span&gt;
    &lt;/span&gt;
  \{{else}}
    Whoops! Could not find "\{{item}}".
  \{{/unless}}
\{{/paper-autocomplete}}{{/code-block}}
{{/paper-card-content}}
{{/paper-card}}



{{#paper-card}}
{{#paper-card-content}}
    <h2>Floating Label</h2>
    <blockquote>The following example demonstrates floating labels being used as a normal form element.</blockquote>
    {{paper-autocomplete floating=true placeholder="Select a Country ..." source=items lookupKey="name" model=thirdModel}}
    <p>Selected country is
      {{#if thirdModel}}
        {{thirdModel.name}}
          ({{thirdModel.code}})
      {{else}}
          Nothing selected...
      {{/if}}
    </p>


<h3>Template</h3>
{{#code-block language='handlebars'}}
\{{paper-autocomplete floating=true placeholder="Select a Country ..." source=items lookupKey="name" model=thirdModel}}{{/code-block}}

{{/paper-card-content}}
{{/paper-card}}


<h2>Attributes for paper-autocomplete</h2>

<table>
    <thead>
    <tr>
        <th>Attribute name</th>
        <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>source</td>
        <td>The <code>source</code> attribute is used to look up possible suggestions for the autocomplete.
          The source attribute accepts:
        <ul>
            <li><strong>Array of strings:</strong> Simple array of strings. Example: <code>['One', 'Two']</code></li>
            <li><strong>Function:</strong> A function that returns a promise. This is useful if you want to fetch suggestions from the server-side with e.g. Ember-data or jQuery's $.ajax method. The search string is passed as the first parameter to this function.</li>
            <li><strong>Array of objects:</strong> If you pass array of objects, paper-autocomplete needs to know what key in each object to search in. Use in combination with <code>lookupKey</code>. Example if you have provided <code>[{id: 1, name="Car"}]</code> as source, you will also need to configure the lookupKey to <code>lookupKey="name"</code>.</li>
        </ul>
        </td>
    </tr>
    <tr>
        <td>model</td>
        <td>When a user selects item from the suggestions, model will be set and updated. Provide a model so you can do something about the value when user clicks the item.</td>
    </tr>
    <tr>
        <td>minLength</td>
        <td>Sets how many characters the user must type before the autocomplete gives suggestions. Default is <code>1</code>.</td>
    </tr>
    <tr>
        <td>delay</td>
        <td>The delay attribute lets you configure how many milliseconds to wait before we trigger a search, this is
            useful to avoid mass sending HTTP requests to your backend if you are using Function based source with
            AJAX calls. Somewhere around <em>300 ms</em> is good.</td>
    </tr>
    <tr>
        <td>noCache</td>
        <td>Only effective if you use promise as source. This disables the cache of promise loaded suggestions. By default they are cached when loaded the first time.</td>
    </tr>
    <tr>
        <td>floating</td>
        <td>Makes the autocomplete field a normal input field with floating labels.</td>
    </tr>
    <tr>
        <td>disabled</td>
        <td>Disables the autocomplete.</td>
    </tr>
    <tr>
        <td>required</td>
        <td>Makes the autocomplete a required field.</td>
    </tr>
    <tr>
        <td>placeholder</td>
        <td>Sets a placeholder for the autocomplete input field.</td>
    </tr>
    <tr>
        <td>allowNonExisting</td>
        <td>allowNonExisting is useful for search boxes. It allows to use items that are not in the autocomplete selection. If you type e.g. "Chees" the model will also be set to "Chees".</td>
    </tr>
    </tbody>
</table>


  </div>
{{/paper-content}}
